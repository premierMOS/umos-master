# Configure the AWS provider
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0" # Specify a compatible version
    }
    tls = {
      source  = "hashicorp/tls"
      version = "~> 4.0" # Specify a compatible version
    }
    random = {
      source  = "hashicorp/random"
      version = "~> 3.0" # Used for unique naming
    }
  }
}

# Define the AWS provider configuration
provider "aws" {
  region = "us-east-1" # Region as specified in the configuration
}

# Generate a new SSH key pair using the tls_private_key resource
# This key will be used to access the deployed Linux virtual machine.
resource "tls_private_key" "admin_ssh" {
  algorithm = "RSA"
  rsa_bits  = 4096
  # CRITICAL: The 'comment' argument is forbidden for tls_private_key.
}

# Helper resource to generate a random suffix for names to ensure uniqueness
resource "random_id" "instance_suffix" {
  byte_length = 4
}

# Create an AWS Key Pair resource using the public key generated by tls_private_key
resource "aws_key_pair" "admin_key" {
  key_name   = "admin-key-${random_id.instance_suffix.hex}" # Dynamic key name to avoid conflicts
  public_key = tls_private_key.admin_ssh.public_key_openssh
}

# Data source to find the custom AWS AMI ID based on the provided image name.
# The 'amazon-linux-2023-19199576595' is used as specified in critical instructions.
data "aws_ami" "this_ami" {
  most_recent = true      # Get the most recent AMI matching the criteria
  owners      = ["self"]  # Look for AMIs owned by the current account

  filter {
    name   = "name"
    values = ["amazon-linux-2023-19199576595"] # Filter by the custom image name
  }
}

# Data source to get the default VPC, which is often required for security groups
data "aws_vpc" "default" {
  default = true
}

# Create a security group to allow SSH access (port 22) to the VM.
# WARNING: Allowing SSH from "0.0.0.0/0" is not recommended for production environments.
# Restrict `cidr_blocks` to known IP ranges for better security.
resource "aws_security_group" "ssh_access" {
  name        = "ssh-access-for-${random_id.instance_suffix.hex}"
  description = "Allow SSH inbound traffic"
  vpc_id      = data.aws_vpc.default.id # Associate with the default VPC

  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"] # Allow SSH from any IP
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"] # Allow all outbound traffic
  }

  tags = {
    Name = "ssh-access-sg-${random_id.instance_suffix.hex}"
  }
}

# Deploy the virtual machine instance
# The resource is named "this_vm" as per critical instructions.
resource "aws_instance" "this_vm" {
  ami             = data.aws_ami.this_ami.id # Use the ID from the data source for the custom image
  instance_type   = "t3.micro"               # Instance size as specified in the configuration
  key_name        = aws_key_pair.admin_key.key_name # Attach the generated SSH key pair
  vpc_security_group_ids = [aws_security_group.ssh_access.id] # Attach the security group for SSH

  # The custom script argument is omitted as per instructions "not yet supported for direct deployment."
  # user_data = "#!/bin/bash\n# User data scripts are not yet supported for direct deployment.\n"

  tags = {
    Name = "test-ip-1" # Instance name as specified in the configuration
  }
}

# Output block for the private IP address of the created virtual machine
# The output is named "private_ip" as per critical instructions.
output "private_ip" {
  description = "The private IP address of the virtual machine."
  value       = aws_instance.this_vm.private_ip
}

# Output block for the generated private SSH key
# This output is marked as sensitive and named "private_ssh_key" as per critical instructions.
output "private_ssh_key" {
  value     = tls_private_key.admin_ssh.private_key_pem
  sensitive = true
}