terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    tls = {
      source  = "hashicorp/tls"
      version = "~> 4.0"
    }
  }
}

# --- Variables ---

variable "instance_name" {
  description = "The name of the virtual machine instance."
  type        = string
  default     = "test2-multi-2" # Value derived from JSON configuration
}

variable "region" {
  description = "The AWS region to deploy the instance in."
  type        = string
  default     = "us-east-1" # Value derived from JSON configuration
}

variable "vm_size" {
  description = "The EC2 instance type (e.g., t3.micro)."
  type        = string
  default     = "t3.micro" # Value derived from JSON configuration
}

variable "custom_script" {
  description = "User data script to execute on instance launch."
  type        = string
  default     = "#!/bin/bash\n# User data scripts are not yet supported for direct deployment.\n" # Value derived from JSON configuration
}

# --- AWS Provider Configuration ---

provider "aws" {
  region = var.region
}

# --- Data Sources ---

# Look up the default VPC for the current AWS account and region.
# This ensures that resources like security groups and subnets are correctly identified
# within the account's default networking infrastructure.
data "aws_vpc" "default" {
  default = true
}

# Look up all default subnets within the identified default VPC.
# The virtual machine will be launched into the first available subnet from this list.
# CRITICAL: Uses "aws_subnets" (plural) as per instructions; "aws_subnet_ids" is deprecated.
data "aws_subnets" "default_subnets" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
}

# Look up the custom Amazon Machine Image (AMI) by its exact cloud image name.
# CRITICAL: Uses the exact image name 'amazon-linux-2023-19210138993' as provided.
data "aws_ami" "custom_image" {
  most_recent = true
  owners      = ["self"] # Search only AMIs owned by the current AWS account

  filter {
    name   = "name"
    values = ["amazon-linux-2023-19210138993"]
  }
}

# --- SSH Key Pair Generation ---

# Generate a new TLS private key locally. This key will be used for SSH access to the VM.
# CRITICAL: The 'comment' argument is explicitly forbidden for 'tls_private_key'.
resource "tls_private_key" "admin_ssh" {
  algorithm = "RSA"
  rsa_bits  = 4096
}

# Create an AWS EC2 Key Pair resource using the public key generated by 'tls_private_key'.
# CRITICAL: 'key_name_prefix' is used instead of 'key_name' to prevent naming collisions on retries.
resource "aws_key_pair" "admin_key" {
  key_name_prefix = "${var.instance_name}-key-"
  public_key      = tls_private_key.admin_ssh.public_key_openssh
}

# --- Security Group Configuration ---

# Create an AWS Security Group to control inbound and outbound network traffic for the VM.
# CRITICAL: 'name_prefix' is used for uniqueness and to avoid naming collisions on retries.
resource "aws_security_group" "this_sg" {
  name_prefix = "${var.instance_name}-sg-"
  description = "Security group for ${var.instance_name} instance"
  vpc_id      = data.aws_vpc.default.id # Associate with the default VPC

  # CRITICAL: Allows all egress traffic (all protocols, all ports, to all destinations '0.0.0.0/0').
  # This is a common setup to allow instances to initiate outbound connections (e.g., for updates, SSM).
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  # CRITICAL: No ingress blocks are defined as per instructions.
  # Inbound access should be managed via AWS Systems Manager (SSM) or other secure, controlled means.
}

# --- IAM Role and Instance Profile for AWS Systems Manager (SSM) ---

# Create an IAM role that EC2 instances can assume to interact with AWS services,
# specifically for AWS Systems Manager (SSM) functionality.
# CRITICAL: 'name_prefix' is used for the role name to ensure uniqueness.
resource "aws_iam_role" "ssm_role" {
  name_prefix        = "${var.instance_name}-ssm-role-"
  description        = "IAM role for SSM access to ${var.instance_name}"
  # The assume role policy trusts the EC2 service, allowing instances to assume this role.
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "ec2.amazonaws.com"
        }
      },
    ]
  })
}

# Attach the AWS managed policy "AmazonSSMManagedInstanceCore" to the created IAM role.
# This policy grants the necessary permissions for the SSM agent running on the EC2 instance
# to communicate with the SSM service.
resource "aws_iam_role_policy_attachment" "ssm_policy_attach" {
  role       = aws_iam_role.ssm_role.name
  # CRITICAL: Explicitly uses the ARN for the AmazonSSMManagedInstanceCore policy.
  policy_arn = "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"
}

# Create an IAM instance profile. Instance profiles are containers for an IAM role
# that you can use to pass role information to an EC2 instance.
# CRITICAL: 'name_prefix' is used for the instance profile name.
resource "aws_iam_instance_profile" "ssm_profile" {
  name_prefix = "${var.instance_name}-ssm-profile-"
  role        = aws_iam_role.ssm_role.name # Link to the SSM IAM role created above
}

# --- Virtual Machine Deployment ---

# Deploy the AWS EC2 virtual machine instance.
# CRITICAL: The primary compute resource MUST be named "this_vm".
resource "aws_instance" "this_vm" {
  ami                         = data.aws_ami.custom_image.id            # Use the ID of the custom AMI found.
  instance_type               = var.vm_size                             # Instance size from the 'vm_size' variable.
  subnet_id                   = data.aws_subnets.default_subnets.ids[0] # CRITICAL: Launch into the first available default subnet.
  associate_public_ip_address = true                                    # CRITICAL: Required for SSM agent connectivity in public subnets.
  key_name                    = aws_key_pair.admin_key.key_name         # CRITICAL: Attach the generated AWS Key Pair for SSH.
  vpc_security_group_ids      = [aws_security_group.this_sg.id]         # CRITICAL: Associate with the created security group.
  # CRITICAL: User data is passed using 'user_data_base64' and base64 encoded.
  user_data_base64            = base64encode(var.custom_script)

  # CRITICAL: Attach the IAM instance profile for SSM access.
  iam_instance_profile = aws_iam_instance_profile.ssm_profile.name

  tags = {
    Name        = var.instance_name
    Environment = "ManagedServiceDeployment" # Example tag for identification
  }

  # CRITICAL: Explicit dependency to prevent race conditions. Ensures the IAM policy
  # is fully attached to the role before the instance attempts to assume it.
  depends_on = [
    aws_iam_role_policy_attachment.ssm_policy_attach
  ]
}

# --- Outputs ---

# Output the private IP address of the newly created virtual machine.
output "private_ip" {
  description = "The private IP address of the virtual machine."
  value       = aws_instance.this_vm.private_ip
}

# Output the cloud provider's native instance ID for the virtual machine.
output "instance_id" {
  description = "The cloud provider's native instance ID."
  value       = aws_instance.this_vm.id
}

# Output the generated private SSH key.
# CRITICAL: This output MUST be marked as sensitive to prevent it from being
# displayed in plaintext in Terraform logs and state files (when possible).
output "private_ssh_key" {
  description = "The generated private SSH key for accessing the instance."
  value       = tls_private_key.admin_ssh.private_key_pem
  sensitive   = true
}